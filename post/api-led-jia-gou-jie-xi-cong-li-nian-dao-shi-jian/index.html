<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>API-Led 架构解析：从理念到实践 | 0707‘s Blog</title>
<link rel="shortcut icon" href="https://windrunner0707.tech/favicon.ico?v=1766317230703">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://windrunner0707.tech/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="API-Led 架构解析：从理念到实践 | 0707‘s Blog - Atom Feed" href="https://windrunner0707.tech/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="概述
在数字化转型的浪潮中，API（应用程序接口） 已经不仅仅是技术上的一个接口，而逐渐演变为组织与外部世界交互的“产品化能力”。企业希望通过 API 将内部系统的价值释放出来，实现更快的创新和更强的业务弹性。
在众多集成架构中，API-L..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://windrunner0707.tech">
  <img class="avatar" src="https://windrunner0707.tech/images/avatar.png?v=1766317230703" alt="">
  </a>
  <h1 class="site-title">
    0707‘s Blog
  </h1>
  <p class="site-description">
    Software Developer
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              API-Led 架构解析：从理念到实践
            </h2>
            <div class="post-info">
              <span>
                2025-09-30
              </span>
              <span>
                5 min read
              </span>
              
            </div>
            
              <img class="post-feature-image" src="https://windrunner0707.tech/post-images/api-led-jia-gou-jie-xi-cong-li-nian-dao-shi-jian.jpg" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <h1 id="概述">概述</h1>
<p>在数字化转型的浪潮中，API（应用程序接口） 已经不仅仅是技术上的一个接口，而逐渐演变为组织与外部世界交互的“产品化能力”。企业希望通过 API 将内部系统的价值释放出来，实现更快的创新和更强的业务弹性。<br>
在众多集成架构中，API-Led 架构（API-Led Connectivity） 逐渐成为主流，尤其在金融、零售和制造业等领域广泛采用。</p>
<h1 id="什么是-api-led-架构">什么是 API-Led 架构</h1>
<p>API-Led 架构由 MuleSoft 提出，它强调通过分层API 来实现系统集成和业务能力的复用。核心思想是：</p>
<p>不再直接做点对点集成，也不仅仅是暴露单一 API，而是将 API 进行分层设计。</p>
<figure data-type="image" tabindex="1"><img src="https://windrunner0707.tech/post-images/1759238612483.png" alt="" loading="lazy"></figure>
<p>典型的三层：</p>
<ul>
<li>
<p>System API：屏蔽底层系统的复杂性，负责访问数据库、ERP、CRM 等。</p>
</li>
<li>
<p>Process API：聚合和编排多个系统 API，实现业务逻辑。</p>
</li>
<li>
<p>Experience API：面向不同渠道（Web、App、合作伙伴），提供定制化的数据和服务。</p>
</li>
</ul>
<p>这种分层方式的好处是：降低耦合、增强复用、提升敏捷性。</p>
<figure data-type="image" tabindex="2"><img src="https://windrunner0707.tech/post-images/1759238658029.png" alt="" loading="lazy"></figure>
<h1 id="api-led架构与微服务架构的区别">API-Led架构与微服务架构的区别</h1>
<p>很多人会把API-Led和微服务混淆，二者虽然相关，但关注点不同：</p>
<h2 id="关注层面不同">关注层面不同</h2>
<p>微服务架构：强调将单体应用拆分为小而独立的服务，每个服务独立开发、部署、扩展。</p>
<p>API-Led 架构：强调系统之间如何互联互通，如何通过 API 实现复用与治理。</p>
<h2 id="目标不同">目标不同</h2>
<p>微服务：解决“系统内部分解”的问题。</p>
<p>API-Led：解决“跨系统集成”的问题。</p>
<h2 id="实现方式不同">实现方式不同</h2>
<p>微服务内部可能直接暴露 API，但往往没有分层概念。</p>
<p>API-Led 强调分层 API，避免直接对接，提升灵活性。</p>
<p>可以理解为：微服务是系统构建方式，而 API-Led 是系统之间的连接方式。两者是互补关系，而不是替代关系。</p>
<h1 id="api-led-架构为什么在银行领域广泛使用">API-Led 架构为什么在银行领域广泛使用</h1>
<p>银行 IT 系统复杂，往往包含核心账务系统、支付清算系统、风控系统、CRM、渠道系统（柜面、网银、手机银行）等。这种环境下：</p>
<ul>
<li>
<p>系统异构严重：老的核心系统可能基于 COBOL，新应用可能基于 Java 或微服务。</p>
</li>
<li>
<p>集成需求频繁：需要快速上线新产品（如理财、贷款、联合营销）。</p>
</li>
<li>
<p>安全与合规要求高：需要统一的 API 管理与访问控制。</p>
</li>
</ul>
<p>API-Led 架构能够在银行中带来显著价值：</p>
<ul>
<li>
<p>屏蔽遗留系统复杂性（通过 System API 封装）。</p>
</li>
<li>
<p>支持快速业务编排（通过 Process API 实现跨系统流程）。</p>
</li>
<li>
<p>支撑多渠道一致体验（通过 Experience API 同时服务网银、手机 App、合作伙伴接口）。</p>
</li>
<li>
<p>统一治理和合规（API 网关+API 管理平台）。</p>
</li>
</ul>
<p>因此，几乎所有大型银行都在推行 API-Led 架构，用于支持开放银行和数字化转型。</p>
<h1 id="api-led-架构的优缺点">API-Led 架构的优缺点</h1>
<h2 id="优点">优点：</h2>
<ul>
<li>
<p>解耦性强：通过分层 API，底层系统改造不会影响上层应用。</p>
</li>
<li>
<p>复用性高：System API 和 Process API 可被多个 Experience API 重用。</p>
</li>
<li>
<p>敏捷性好：业务逻辑调整只需修改 Process API，开发效率提升。</p>
</li>
<li>
<p>治理完善：便于统一做 API 管理、监控、安全认证。</p>
</li>
<li>
<p>支持开放生态：银行、保险等可快速对接合作伙伴 API。</p>
</li>
</ul>
<h2 id="缺点">缺点：</h2>
<ul>
<li>
<p>设计复杂度提升：需要良好的 API 设计规范和治理体系。</p>
</li>
<li>
<p>实现成本高：需要 API 管理平台（如 MuleSoft、Kong、Apigee）。</p>
</li>
<li>
<p>性能挑战：层级过多可能带来调用链路长、延迟增加。</p>
</li>
<li>
<p>组织协同要求高：API-Led 要求跨部门统一治理，否则容易变成“新的烟囱”。</p>
</li>
</ul>
<h1 id="总结">总结</h1>
<p>API-Led 架构代表了企业集成架构的新趋势。它通过分层API将底层系统能力“产品化”，实现跨系统的复用、解耦和治理。与微服务架构相比，API-Led 更关注“连接”与“复用”，在金融、零售、制造等多系统并存的行业尤其重要。<br>
在银行领域，API-Led架构不仅解决了遗留系统与新系统的集成问题，也为开放银行和金融科技创新提供了基础。<br>
当然，API-Led 架构也带来设计、治理、性能等方面的新挑战。企业在落地时，需要结合自身情况，配合 API 网关、监控体系、团队治理机制，才能真正发挥其价值。</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E6%A6%82%E8%BF%B0">概述</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-api-led-%E6%9E%B6%E6%9E%84">什么是 API-Led 架构</a></li>
<li><a href="#api-led%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E5%8C%BA%E5%88%AB">API-Led架构与微服务架构的区别</a>
<ul>
<li><a href="#%E5%85%B3%E6%B3%A8%E5%B1%82%E9%9D%A2%E4%B8%8D%E5%90%8C">关注层面不同</a></li>
<li><a href="#%E7%9B%AE%E6%A0%87%E4%B8%8D%E5%90%8C">目标不同</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E4%B8%8D%E5%90%8C">实现方式不同</a></li>
</ul>
</li>
<li><a href="#api-led-%E6%9E%B6%E6%9E%84%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8%E9%93%B6%E8%A1%8C%E9%A2%86%E5%9F%9F%E5%B9%BF%E6%B3%9B%E4%BD%BF%E7%94%A8">API-Led 架构为什么在银行领域广泛使用</a></li>
<li><a href="#api-led-%E6%9E%B6%E6%9E%84%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">API-Led 架构的优缺点</a>
<ul>
<li><a href="#%E4%BC%98%E7%82%B9">优点：</a></li>
<li><a href="#%E7%BC%BA%E7%82%B9">缺点：</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://windrunner0707.tech/post/fan-yi-jie-kai-shu-ju-ku-suo-yin-de-shen-mi-mian-sha-suo-yin-lei-xing-yu-yong-li/">
              <h3 class="post-title">
                （翻译）揭开数据库索引的神秘面纱：索引类型与用例
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://windrunner0707.tech/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
